<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report # 4 </h1>
    <p class="author">
      Alecia Young <br />
      March 14, 2025
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>

	Module 4 focused on recusion and fractal trees. Recursion is a function that calls itself. It breaks down a problem into simpler steps until it reaches the simplest or most fundamental case, the base case. This method works analytically, starting from the data and repeating itself until the base case is achieved. It follows a top-down approach, reducing tasks as it calls itself repeatedly [1]. <br><br>
	
	<b>Parts of Recursion:</b> <br>
	1) <b>Base Case:</b> This is the condition that terminates the recursive method. It is the fundamental step that can be solved without additional recursive calls. When this condition is met, the recursive method begins to unwind, returning a value at each level of recursion that is resolved.<br><br>
	2) <b>Recursive Step:</b> This step, which is generally based on the principle of mathematical induction, defines a problem in terms of smaller subproblems. It involves invoking the same function with a reduced set of inputs. <br><br>
	3) <b>Return Value:</b> This combines various outputs produced by the recursive calls. It typically involves aggregating or calculating data based on the results of these calls. <br><br>

	Fractal trees are patterns that exhibit self-similarity, meaning they repeat the same shape or design at different scales. Several algorithms can be used to generate fractal trees, but the simplest method is the recursive approach. Recursion reduces the effort of defining numerous variables and prevents spaghetti code. <br><br> 
	      
	<h2>First Code: Fractal Tree </h2>
        <p>
  
        The first code in Module 4 constructs a Fractal Tree using recursion. The fractal_tree function begins by moving the turtle forward to draw the main branch. It then recursively creates two smaller branches: one to the left and one to the right, each at a 30-degree angle to the main branch. This process continues, with each branch generating two smaller branches, until the specified recursion depth is reached. Afterward, the turtle backtracks to its previous position, ensuring the tree structure is generated accurately.<br><br>

	<u><b>Breakdown of the Code:</b></u> <br><br>
	1) Base Case (if depth == 0): The recursion stops when the depth parameter reaches zero, indicating that no further branching should happen at this level.<br><br>
	2) Drawing the Main Branch (forward(length)): The turtle moves forward by the specified length, drawing the main branch of the current recursion level.<br><br>
	3) Left Subtree: The turtle turns left by 30 degrees (left(30)). A recursive call to fractal_tree is made with a reduced length (length * 0.7) and decreased depth (depth - 1), drawing the left subtree. <br><br>
	4) Right Subtree: After completing the left subtree, the turtle turns 60 degrees to the right (right(60)) from its current heading. It then makes another recursive call to fractal_tree with the same reduced length and depth to draw the right subtree.<br><br>
	5) Resetting Position and Orientation: The turtle turns left by 30 degrees (left(30)) to realign with its original heading before the recursive calls. It then moves backward by the original branch length (backward(length)) to return to the starting position of the current branch, ensuring that subsequent branches are drawn correctly.<br><br>
		
	</p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">
		
	# Function to draw a fractal tree using recursion
	def fractal_tree(length, depth):
	    if depth == 0:
		return
	    else:
		forward(length)
		left(30)
		
		fractal_tree(length * 0.7, depth - 1)
		
		right(60)
		
		fractal_tree(length * 0.7, depth - 1)
		
		left(30)
		backward(length)


	# Initialize the turtle
	initializeTurtle(initial_window_size=(500, 500))
	
	# Set up the turtle's starting position and orientation
	jump(250, 450)  # Starting position at the bottom center of the canvas
	face(0)
	color('green')  # Set the pen color
	
	# Set the length and depth for the fractal tree
	length = 100  # Initial length of the main trunk
	depth = 10     # Recursion depth (number of branching levels)

	# Draw the fractal tree
	fractal_tree(length, depth)
	
	# Display the drawing
	show()
	</code></pre>


	 </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          The diagram below shows the code for the Brownian motion. 
        </p>

        <figure>
          <img
            src="https://github.com/ayoung37/labreports/blob/main/Equilateral%20Triangle.PNG?raw=true"
            alt="Turtle Graphics Broad View"
            width="500"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong><br>Figure 1:</strong> Equilateral triangle created using turtle graphics.
          </figcaption>
        </figure>


      </section>


	<h2>Second Code: Sierpinski Triangle Using Turtle Graphics </h2>
	
	The code defines a recursive function called 'sierpinski_triangle(length, order)' that draws a Sierpinski triangle. The base case for the recursion occurs when the order is 0; in this case, the function draws a simple equilateral triangle. If the order is greater than 0, the function recursively calls itself three times with half the length and one less order, positioning the three smaller Sierpinski triangles to form a larger triangle. <br> 
	I modified the code to generate the Sierpinski triangle for orders 1 through 4. Initially, the code was created to display the Sierpinski triangle for order 4. Below is the additional code I implemented in the initial version:
	    
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">
		
	# Define the recursive Sierpinski triangle function
	def sierpinski_triangle(length, order):
	     if order == 0:
		draw_triangle(length)
             else:
		sierpinski_triangle(length / 2, order - 1)
		forward(length / 2)
		sierpinski_triangle(length / 2, order - 1)
		backward(length / 2)
		left(60)
		forward(length / 2)
		right(60)
		sierpinski_triangle(length / 2, order - 1)
		left(60)
		backward(length / 2)
		right(60)



	initializeTurtle()
	showturtle()
	# Set up the turtle
	jump(100, 200)
	face(90)
	color('green')

	# Draw the Sierpinski triangle order 1
	length = 200
	order = 1
	sierpinski_triangle(length, order)


	# Set up the turtle
	jump(400, 200)
	face(90)
	color('red')

	# Draw the Sierpinski triangle order 2
	length = 200
	order = 2
	sierpinski_triangle(length, order)

	# Set up the turtle
	jump(100, 500)
	face(90)
	color('blue')

	# Draw the Sierpinski triangle order 3
	length = 200
	order = 3
	sierpinski_triangle(length, order)

	# Set up the turtle
	jump(400, 500)
	face(90)
	color('magenta')

	# Draw the Sierpinski triangle order 4
	length = 300
	order = 4
	sierpinski_triangle(length, order)
	show()
		
	</code></pre>

	
      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
           
        </p>

        <figure>
          <img
            src="https://github.com/ayoung37/labreports/blob/main/Sierpinski%20Triangle.PNG?raw=true"
            alt="Turtle Graphics Broad View"
            width="500"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong><br>Figure 2:</strong> Illustration of Sierpinski Triangles from order 1 to order 4.
          </figcaption>
        </figure>



      </section>


<h2>Third Code: Cellular  Automata  </h2>
	
	The code simulates and visualizes a one-dimensional Cellular Automaton. A one-dimensional Cellular Automaton (CA) consists of either black or white cells [2]. 
	    
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">
	import numpy as np
import matplotlib.pyplot as plt

def plot(x):
    fig, ax = plt.subplots()
    im = ax.imshow(x, cmap = 'gray')
    ax.axis('off')
    fig.set_size_inches(10, 10)
    plt.show()

C = np.zeros((100,100)).astype(int)
C[0,50] = 1
plot(C)

num = 90
print(f'{num:08b}')

rule = np.zeros((2,2,2))

rule[0,0,0] = 0
rule[0,0,1] = 1
rule[0,1,0] = 0
rule[0,1,1] = 1
rule[1,0,0] = 1
rule[1,0,1] = 0
rule[1,1,0] = 1
rule[1,1,1] = 0


def CA(X):

    for i in range(1,X.shape[0]-1): #row
        for j in range(1,X.shape[1]-1): #col

            N  = X[i-1,j]
            NW = X[i-1,j-1]
            NE = X[i-1,j+1]

            X[i,j] = rule[NW,N,NE]

    return X


def CA(X):

    for i in range(1,X.shape[0]-1): #row
        for j in range(1,X.shape[1]-1): #col

            X[i,j] = (rule/(2**(4*X[i-1,j-1] + 2*X[i-1,j] + X[i-1,j+1]))) % 2

    return X

rule = 90

plot(CA(C))


for rule in [30, 62, 90, 110, 126]:
    plot(CA(C))
		
	</code></pre>

	
      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
           
        </p>

        <figure>
          <img
            src="https://github.com/ayoung37/labreports/blob/main/Cellular%20Automata.PNG?raw=true"
            alt="Turtle Graphics Broad View"
            width="500"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong><br>Figure 2:</strong> Illustration of Cellular Automata.
          </figcaption>
        </figure>



      </section>


      </section>



      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------- ----------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
        Module 3 demonstrates how the turtle graphics and cellular automata can be used to generate the Sierpinski fractal patterns. 
		
	</p>
      </section>

	 <!-- REFERENCE SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------- ----------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
	    
	<section id="References">
        <h2>Reference</h2>
        <p> 
	[1] (2023, March 1). Fractal Trees in Java | Recursion Explained. Medium. https://projectjava.medium.com/fractal-trees-in-java-recursion-explained-7bc1b6e6bd57 <br><br>
	[2] https://youtu.be/ob8teyuR8dA?si=QyFX0cws_tw9s9rr <br><br>
	
	
	</p>
	
      </section>
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
