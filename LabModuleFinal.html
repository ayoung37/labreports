
<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report <br> Final </h1>
    <p class="author">
      Alecia Young <br />
      April 28, 2025
    </p>
  </header>
  

  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>

	The final lab report for the semester is divided into three parts.<br>
	- Part 1 focuses on Chaos Games, which includes the Sierpinski Triangle and the Barnsley Fern.<br> 
	- Part 2 covers L-Systems and fractal trees.<br>
	- Part 3 focuses on the Hilbert Curves.<br>
	      
	<h2>Part 1: Chaos Games </h2>
        <p>
	A chaos game is a method for generating iterative fractals using polygons and a randomly selected initial point within them[1]. It applies specific starting conditions that unfold deterministically based on a defined set of rules, incorporating randomly generated points to create the fractals[2].<br><br>

	<u><b>The Sierpinski Triangle </b></u><br>
	The program begins with three coordinates that represent the corners of an equilateral triangle. From these corners, one is randomly selected, and a dot is drawn at the midpoint between that corner and an initial random point. In each subsequent step of the process, a new dot is drawn at the midpoint between the previous dot and another randomly selected corner of the triangle. This procedure is repeated, and over time, a Sierpinski triangle begins to form.<br><br>
	
	The code begins by importing the following functions: <br>
	<b>import matplotlib.pyplot as plt <br>
	from random import random, randint <br>
	import numpy as np</b><br>

	The function <b>'def midpoint(P, Q):'</b> calculates the midpoint between two points, P and Q.  <br>

	The variable <b>'vertices = [(0, 0), (2, 2*np.sqrt(3)), (4, 0)]'</b> defines the three vertices of the equilateral triangle. <br>

	The variable <b>'iterates = 50000'</b> is the number of points that will be plotted. <br>

	The array <b>'x, y = [0]*iterates, [0]*iterates'</b> initialized to store all the points. <br>

	The loop <b>'for i in range(1, iterates):'</b> randomly selects one of the three vertices. Move halfway from the current point to the chosen vertex and store the new point. <br>

	<b>plt.figure(figsize=(8, 8)) <br>
	plt.scatter(x, y, color = 'r', s=0.1) <br>
	plt.title('Sierpinski Triangle Generated Using the Chaos Game')<br>
	plt.axis('equal')  # Ensure aspect ratio is equal for an equilateral triangle <br>
	plt.show()</b><br>
	
	This section of the code is responsible for visualizing the Sierpinski Triangle. 
	</p>
      </section>
     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

import matplotlib.pyplot as plt
from random import random, randint
import numpy as np

def midpoint(P, Q):
    return (0.5*(P[0] + Q[0]), 0.5*(P[1] + Q[1]))

vertices = [(0, 0), (2, 2*np.sqrt(3)), (4, 0)]
iterates = 50000
x, y = [0]*iterates, [0]*iterates
x[0], y[0] = random(), random()

for i in range(1, iterates):

    k = randint(0, 2)

    x[i], y[i] = midpoint( vertices[k], (x[i-1], y[i-1]) )

plt.figure(figsize=(8, 8))
plt.scatter(x, y, color = 'r', s=0.1)
plt.title('Sierpinski Triangle Generated Using the Chaos Game')
plt.axis('equal')  # Ensure aspect ratio is equal for an equilateral triangle
plt.show()

	</code></pre>


	 </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          The diagram below shows the Sierpinski Triangle generated using a Chaos Game
        </p>

        <figure>
          <img
            src="https://github.com/ayoung37/labreports/blob/main/Sierpinski%20Triangle%20(Chaos%20Game).PNG?raw=true"
            alt="Turtle Graphics Broad View"
            width="500"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong><br>Figure 1:</strong> Sierpinski Triangle generated using a Chaos Game.
          </figcaption>
        </figure>


      </section>


	<u><b>The Barnsley Fern </b></u><br>
	Barnsley's Fern is an example of a random point iteration that generates a fractal pattern. The transformation rules take any point (x, y) and return new values for x and y [3]. The transformation functions are defined as follows: <br>

def f1(x, y): <br>
    x = 0 <br>
    y = 0.16 * y <br>
    return x, y<br> 

def f2(x, y): <br>
    x_new = 0.85 * x + 0.04 * y <br>
    y_new = -0.04 * x + 0.85 * y + 1.6 <br>
    return x_new, y_new <br>

def f3(x, y): <br>
    x_new = 0.2 * x - 0.26 * y <br>
    y_new = 0.23 * x + 0.22 * y + 1.6 <br>
    return x_new, y_new <br>

def f4(x, y): <br>
    x_new = -0.15 * x + 0.28 * y <br>
    y_new = 0.26 * x + 0.24 * y + 0.44 <br>
    return x_new, y_new <br>
	    
These functions provide the necessary transformations to create the intricate fractal shape characteristic of Barnsley's Fern. <br> 

The first function, `f1`, represents the fern stem. The second function, `f2`, creates the largest portion of the Fern, which is the leafy part. The third function, `f3`, draws a smaller left leaflet, while the fourth function, `f4`, draws the smaller right leaflet.<br>

	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

import random
import matplotlib.pyplot as plt

# Define the transformation functions
def f1(x, y):
    x = 0
    y = 0.16 * y
    return x, y

def f2(x, y):
    x_new = 0.85 * x + 0.04 * y
    y_new = -0.04 * x + 0.85 * y + 1.6
    return x_new, y_new

def f3(x, y):
    x_new = 0.2 * x - 0.26 * y
    y_new = 0.23 * x + 0.22 * y + 1.6
    return x_new, y_new

def f4(x, y):
    x_new = -0.15 * x + 0.28 * y
    y_new = 0.26 * x + 0.24 * y + 0.44
    return x_new, y_new

# Probabilities for each function
probabilities = [0.01, 0.85, 0.07, 0.07]

# Barnsley Fern function
def barnsley_fern(iterations):
    x, y = 0, 0
    points = []

    for _ in range(iterations):
        rand = random.random()
        if rand   < sum(probabilities[:1]):
            x, y = f1(x, y)
        elif rand < sum(probabilities[:2]):
            x, y = f2(x, y)
        elif rand < sum(probabilities[:3]):
            x, y = f3(x, y)
        else:
            x, y = f4(x, y)

        points.append((x, y))

    return points

# Generate points for the Barnsley Fern
iterations = 100000
fern_points = barnsley_fern(iterations)

# Plot the Barnsley Fern
x_vals, y_vals = zip(*fern_points)
plt.figure(figsize=(6, 10))
plt.scatter(x_vals, y_vals, s=0.1, color='orange')
plt.title('Barnsley Fern')
plt.show()

	</code></pre>

 <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          The diagram below shows the Barnsley Fern generated using a Chaos Game
        </p>

        <figure>
          <img
            src="https://github.com/ayoung37/labreports/blob/main/Sierpinski%20Triangle%20(Chaos%20Game).PNG?raw=true"
            alt="Turtle Graphics Broad View"
            width="500"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong><br>Figure 2:</strong> Barnsley Fern generated using a Chaos Game.
          </figcaption>
        </figure>


      </section>

<h2>Part 2: L - Systems </h2>
        <p>
  
        The second code generates a zoomed-in visual of the Mandelbrot Set, performing the same function as the first code but with more concise code. <br>

	</p>
      </section>
     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

# Parameters for the initial zoom level
xmin, xmax, ymin, ymax = -0.75, -0.74, 0.1, 0.11  # Zoom into this specific area
width, height = 800, 800  # Resolution of the image
max_iter = 1000  # Number of iterations

# Generate the Mandelbrot Set with zoom
n3 = mandelbrot_set(xmin, xmax, ymin, ymax, width, height, max_iter)

# Plotting the zoomed Mandelbrot Set
plt.figure(figsize=(10, 10))
plt.imshow(n3.T, extent=[xmin, xmax, ymin, ymax], cmap='hot')
plt.colorbar()
plt.title("Mandelbrot Set - Zoomed In")
plt.show()
	</code></pre>


	 </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          The diagram below shows a zoomed-in portion of the Mandelbrot Set. 
        </p>

        <figure>
          <img
            src="https://github.com/ayoung37/labreports/blob/main/Mandelbrot%20Set%20(2).PNG?raw=true"
            alt="Turtle Graphics Broad View"
            width="500"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong><br>Figure 2:</strong> Close-up view of the Mandelbrot Set, using the same parameters as the first code.
          </figcaption>
        </figure>


      </section>

<h2>Third Code: The Julia Set  </h2>
        <p>
  
	The third code focus on the Julia Set. The Julia Set.<br>

	The code begins by importing the following functions: <br>
	<b>import numpy as np</b> <br>
	<b>import matplotlib.pyplot as plt</b> <br>
	<b>from numba import jit</b> <br>
	The function <b>julia_set(c, xmin, xmax, ymin, ymax, width, height, max_iter)</b> computes the Julia set for a specific complex number c. It iteratively calculates z = z*z + c for every point z in the complex plane. 
	
	</p>
      </section>
     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt
from numba import jit

# JIT-optimized function to generate the Julia Set
@jit(nopython=True)
def julia_set(c, xmin, xmax, ymin, ymax, width, height, max_iter):
    r1 = np.linspace(xmin, xmax, width)
    r2 = np.linspace(ymin, ymax, height)
    n3 = np.empty((width, height))

    for i in range(width):
        for j in range(height):
            z = r1[i] + 1j * r2[j]
            n = 0
            while abs(z) <= 2 and n < max_iter:
                z = z*z + c
                n += 1
            n3[i, j] = n

    return n3

# Parameters for the plot
xmin, xmax, ymin, ymax = -1.5, 1.5, -1.5, 1.5
width, height = 800, 800  # Image resolution
max_iter = 256  # Number of iterations for accuracy

# Choose a value for the complex constant c
c = complex(-0.8, 0.156)

# Generate the Julia Set
n3 = julia_set(c, xmin, xmax, ymin, ymax, width, height, max_iter)

# Plotting the Julia Set
plt.figure(figsize=(10, 10))
plt.imshow(n3.T, extent=[xmin, xmax, ymin, ymax], cmap='hot', interpolation='bilinear')
plt.colorbar()
plt.title(f"Julia Set for c = {c}")
plt.show()
		    
	</code></pre>


	 </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          The diagram below shows the code for the Julia Set. 
        </p>

        <figure>
          <img
            src="https://github.com/ayoung37/labreports/blob/main/Julia%20Set.PNG?raw=true"
            alt="Turtle Graphics Broad View"
            width="500"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong><br>Figure 3:</strong> The Julia Set
          </figcaption>
        </figure>


      </section>


      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------- ----------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
        Module 7 and 8 illustrates how to generate the Mandelbrot Set and Julia Set Fractals using Python.
		
	</p>
      </section>

	 <!-- REFERENCE SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------- ----------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
	    
	<section id="References">
        <h2>Reference</h2>
        <p> 
	[1] https://en.wikipedia.org/wiki/Chaos_game <br>
	[2] https://beltoforion.de/en/recreational_mathematics/chaos_game.php#:~:text=The%20number%20of%20corner%20points,<br>
	randomness%22%20of%20the%20corner%20selection<br>
	[3] https://thewessens.net/ClassroomApps/Main/chaosgame.html
	

	</p>
	
      </section>
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
