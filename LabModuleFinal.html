
<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report <br> Final </h1>
    <p class="author">
      Alecia Young <br />
      April 28, 2025
    </p>
  </header>
  

  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>

	The final lab report for the semester is divided into three parts.<br>
	- Part 1 focuses on Chaos Games, which includes the Sierpinski Triangle and the Barnsley Fern.<br> 
	- Part 2 covers L-Systems and fractal trees.<br>
	- Part 3 focuses on the Hilbert Curves.<br>
	      
	<h2>Part 1: Chaos Games </h2>
        <p>
	A chaos game is a method for generating iterative fractals using polygons and a randomly selected initial point within them[1]. It applies specific starting conditions that unfold deterministically based on a defined set of rules, incorporating randomly generated points to create the fractals[2].<br><br>

	<u><b>The Sierpinski Triangle </b></u><br>
	The program begins with three coordinates that represent the corners of an equilateral triangle. From these corners, one is randomly selected, and a dot is drawn at the midpoint between that corner and an initial random point. In each subsequent step of the process, a new dot is drawn at the midpoint between the previous dot and another randomly selected corner of the triangle. This procedure is repeated, and over time, a Sierpinski triangle begins to form.<br><br>
	
	The code begins by importing the following functions: <br>
	<b>import matplotlib.pyplot as plt <br>
	from random import random, randint <br>
	import numpy as np</b><br>

	The function <b>'def midpoint(P, Q):'</b> calculates the midpoint between two points, P and Q.  <br>

	The variable <b>'vertices = [(0, 0), (2, 2*np.sqrt(3)), (4, 0)]'</b> defines the three vertices of the equilateral triangle. <br>

	The variable <b>'iterates = 50000'</b> is the number of points that will be plotted. <br>

	The array <b>'x, y = [0]*iterates, [0]*iterates'</b> initialized to store all the points. <br>

	The loop <b>'for i in range(1, iterates):'</b> randomly selects one of the three vertices. Move halfway from the current point to the chosen vertex and store the new point. <br>

	<b>plt.figure(figsize=(8, 8)) <br>
	plt.scatter(x, y, color = 'r', s=0.1) <br>
	plt.title('Sierpinski Triangle Generated Using the Chaos Game')<br>
	plt.axis('equal')  # Ensure aspect ratio is equal for an equilateral triangle <br>
	plt.show()</b><br>
	
	This section of the code is responsible for visualizing the Sierpinski Triangle. 
	</p>
      </section>
     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

import matplotlib.pyplot as plt
from random import random, randint
import numpy as np

def midpoint(P, Q):
    return (0.5*(P[0] + Q[0]), 0.5*(P[1] + Q[1]))

vertices = [(0, 0), (2, 2*np.sqrt(3)), (4, 0)]
iterates = 50000
x, y = [0]*iterates, [0]*iterates
x[0], y[0] = random(), random()

for i in range(1, iterates):

    k = randint(0, 2)

    x[i], y[i] = midpoint( vertices[k], (x[i-1], y[i-1]) )

plt.figure(figsize=(8, 8))
plt.scatter(x, y, color = 'r', s=0.1)
plt.title('Sierpinski Triangle Generated Using the Chaos Game')
plt.axis('equal')  # Ensure aspect ratio is equal for an equilateral triangle
plt.show()

	</code></pre>


	 </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          The diagram below shows the Sierpinski Triangle generated using a Chaos Game
        </p>

        <figure>
          <img
            src="https://github.com/ayoung37/labreports/blob/main/Sierpinski%20Triangle%20(Chaos%20Game).PNG?raw=true"
            alt="Turtle Graphics Broad View"
            width="500"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong><br>Figure 1:</strong> Sierpinski Triangle generated using a Chaos Game.
          </figcaption>
        </figure>


      </section>


	<u><b>The Barnsley Fern </b></u><br>
	Barnsley's Fern is an example of a random point iteration that generates a fractal pattern. The transformation rules take any point (x, y) and return new values for x and y [3]. The transformation functions are defined as follows: <br>

def f1(x, y): <br>
    x = 0 <br>
    y = 0.16 * y <br>
    return x, y<br> 

def f2(x, y): <br>
    x_new = 0.85 * x + 0.04 * y <br>
    y_new = -0.04 * x + 0.85 * y + 1.6 <br>
    return x_new, y_new <br>

def f3(x, y): <br>
    x_new = 0.2 * x - 0.26 * y <br>
    y_new = 0.23 * x + 0.22 * y + 1.6 <br>
    return x_new, y_new <br>

def f4(x, y): <br>
    x_new = -0.15 * x + 0.28 * y <br>
    y_new = 0.26 * x + 0.24 * y + 0.44 <br>
    return x_new, y_new <br>
	    
These functions provide the necessary transformations to create the intricate fractal shape characteristic of Barnsley's Fern. <br> 

The first function, `f1`, represents the fern stem. The second function, `f2`, creates the largest portion of the Fern, which is the leafy part. The third function, `f3`, draws a smaller left leaflet, while the fourth function, `f4`, draws the smaller right leaflet.<br>

	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

import random
import matplotlib.pyplot as plt

# Define the transformation functions
def f1(x, y):
    x = 0
    y = 0.16 * y
    return x, y

def f2(x, y):
    x_new = 0.85 * x + 0.04 * y
    y_new = -0.04 * x + 0.85 * y + 1.6
    return x_new, y_new

def f3(x, y):
    x_new = 0.2 * x - 0.26 * y
    y_new = 0.23 * x + 0.22 * y + 1.6
    return x_new, y_new

def f4(x, y):
    x_new = -0.15 * x + 0.28 * y
    y_new = 0.26 * x + 0.24 * y + 0.44
    return x_new, y_new

# Probabilities for each function
probabilities = [0.01, 0.85, 0.07, 0.07]

# Barnsley Fern function
def barnsley_fern(iterations):
    x, y = 0, 0
    points = []

    for _ in range(iterations):
        rand = random.random()
        if rand   < sum(probabilities[:1]):
            x, y = f1(x, y)
        elif rand < sum(probabilities[:2]):
            x, y = f2(x, y)
        elif rand < sum(probabilities[:3]):
            x, y = f3(x, y)
        else:
            x, y = f4(x, y)

        points.append((x, y))

    return points

# Generate points for the Barnsley Fern
iterations = 100000
fern_points = barnsley_fern(iterations)

# Plot the Barnsley Fern
x_vals, y_vals = zip(*fern_points)
plt.figure(figsize=(6, 10))
plt.scatter(x_vals, y_vals, s=0.1, color='orange')
plt.title('Barnsley Fern')
plt.show()

	</code></pre>

 <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          The diagram below shows the Barnsley Fern generated using a Chaos Game
        </p>

        <figure>
          <img
            src="https://github.com/ayoung37/labreports/blob/main/Sierpinski%20Triangle%20(Chaos%20Game).PNG?raw=true"
            alt="Turtle Graphics Broad View"
            width="500"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong><br>Figure 2:</strong> Barnsley Fern generated using a Chaos Game.
          </figcaption>
        </figure>


      </section>

<h2>Part 2: L - Systems </h2>
        <p>
  <u><b>Fractal Trees</b></u><br>



	</p>
      </section>
     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

# Initialize the turtle
initializeTurtle()
showturtle()

# Function to apply L-system rules
def apply_rule(char, rules):
    return rules.get(char, char)

# Function to generate L-system string
def generate_lsystem(axiom, rules, iterations):
    current_string = axiom
    for _ in range(iterations):
        current_string = ''.join([apply_rule(char, rules) for char in current_string])
    return current_string

# Function to draw the L-system with turtle
def draw_lsystem(turtle_string, length, angle):
    stack = []
    for command in turtle_string:
        if command == 'F':
            forward(length)
        elif command == '+':
            left(angle)
        elif command == '-':
            right(angle)
        elif command == '[':
            position = (getx(), gety())
            heading_angle = heading()
            stack.append((position, heading_angle))
        elif command == ']':
            position, heading_angle = stack.pop()
            jump(position[0], position[1])
            face(heading_angle)

# Define the L-system rules
rules = {'F': 'FF+[+F-F-F]-[-F+F+F]'}

axiom = 'F'
iterations = 4

# Generate the L-system string
turtle_string = generate_lsystem(axiom, rules, iterations)

# Set up the turtle
jump(400, 500)
face(0)
color('green')

# Draw the L-system fractal tree
length = 8
angle = 25
draw_lsystem(turtle_string, length, angle)

# Display the drawing
show()

	</code></pre>


	 </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          The diagram below shows the L-System Fractal Tree. 
        </p>

        <figure>
          <img
            src="https://github.com/ayoung37/labreports/blob/main/Mandelbrot%20Set%20(2).PNG?raw=true"
            alt="Turtle Graphics Broad View"
            width="500"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong><br>Figure 3:</strong> L-System Fractal Tree.
          </figcaption>
        </figure>


      </section>

<h2>Part 3: Hilbert Curves  </h2>
        <p>
  
	The third code focus on the Julia Set. The Julia Set.<br>

	The code begins by importing the following functions: <br>
	<b>import numpy as np</b> <br>
	<b>import matplotlib.pyplot as plt</b> <br>
	<b>from numba import jit</b> <br>
	The function <b>julia_set(c, xmin, xmax, ymin, ymax, width, height, max_iter)</b> computes the Julia set for a specific complex number c. It iteratively calculates z = z*z + c for every point z in the complex plane. 
	
	</p>
      </section>
     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">
# Import necessary modules
import math

# Initialize the turtle
initializeTurtle()
showturtle()

# Function to apply L-system rules
def apply_rules(char, rules):
    return rules.get(char, char)

# Function to generate L-system string
def generate_lsystem(axiom, rules, iterations):
    current_string = axiom
    for _ in range(iterations):
        next_string = ''.join([apply_rules(char, rules) for char in current_string])
        current_string = next_string
    return current_string

# Function to draw the L-system with turtle
def draw_lsystem(turtle_string, length, angle):
    for command in turtle_string:
        if command == 'F':
            forward(length)
        elif command == '+':
            left(angle)
        elif command == '-':
            right(angle)
        # 'L' and 'R' are placeholders; we ignore them in drawing
        else:
            pass  # Ignore other characters

# Set the parameters for the Hilbert Curve
axiom = 'L'
rules = {
    'L': '-RF+LFL+FR-',
    'R': '+LF-RFR-FL+'
}
iterations = 5  # Adjust the iterations to change the order (e.g., 1 to 5)
angle = 90

# Generate the L-system string for the Hilbert curve
hilbert_string = generate_lsystem(axiom, rules, iterations)

# Calculate the step size based on desired size and iterations
size = 400  # Total size of the Hilbert curve (adjust as needed)
n = 2 ** iterations - 1
length = size / n

# Move to starting position
jump(400, 500)  # Adjust the starting position to fit your canvas
face(0)
color('blue')

# Draw the Hilbert curve
draw_lsystem(hilbert_string, length, angle)

# Display the drawing
show()
		    
	</code></pre>


	 </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          The diagram below shows the Hilbert Curve. 
        </p>

        <figure>
          <img
            src="https://github.com/ayoung37/labreports/blob/main/Julia%20Set.PNG?raw=true"
            alt="Turtle Graphics Broad View"
            width="500"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong><br>Figure 4:</strong> The Hilbert Curve
          </figcaption>
        </figure>


      </section>


      
	 <!-- REFERENCE SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------- ----------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
	    
	<section id="References">
        <h2>Reference</h2>
        <p> 
	[1] https://en.wikipedia.org/wiki/Chaos_game <br>
	[2] https://beltoforion.de/en/recreational_mathematics/chaos_game.php#:~:text=The%20number<br>
		%20of%20corner%20points,randomness%22%20of%20the%20corner%20selection<br>
	[3] https://thewessens.net/ClassroomApps/Main/chaosgame.html
	

	</p>
	
      </section>
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
