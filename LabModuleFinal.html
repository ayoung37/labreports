
<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report <br> Final </h1>
    <p class="author">
      Alecia Young <br />
      April 28, 2025
    </p>
  </header>
  

  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>

	The final lab report for the semester is divided into three parts.<br>
	- Part 1 focuses on Chaos Games, which includes the Sierpinski Triangle and the Barnsley Fern.<br> 
	- Part 2 covers L-Systems and fractal trees.<br>
	- Part 3 focuses on the Hilbert Curves.<br>
	      
	<h2>Part 1: Chaos Games </h2>
        <p>
	A chaos game is a method for generating iterative fractals using polygons and a randomly selected initial point within them [1]. It applies specific starting conditions that unfold deterministically based on a defined set of rules, incorporating randomly generated points to create the fractals [2].<br><br>

	<u><b>The Sierpinski Triangle </b></u><br>
	The program begins with three coordinates that represent the corners of an equilateral triangle. From these corners, one is randomly selected, and a dot is drawn at the midpoint between that corner and an initial random point. In each subsequent step of the process, a new dot is drawn at the midpoint between the previous dot and another randomly selected corner of the triangle. This procedure is repeated, and over time, a Sierpinski triangle begins to form.<br><br>
	
	The code begins by importing the following functions: <br>
	<b>import matplotlib.pyplot as plt <br>
	from random import random, randint <br>
	import numpy as np</b><br>

	The function <b>'def midpoint(P, Q):'</b> calculates the midpoint between two points, P and Q.  <br>

	The variable <b>'vertices = [(0, 0), (2, 2*np.sqrt(3)), (4, 0)]'</b> defines the three vertices of the equilateral triangle. <br>

	The variable <b>'iterates = 50000'</b> is the number of points that will be plotted. <br>

	The array <b>'x, y = [0]*iterates, [0]*iterates'</b> initialized to store all the points. <br>

	The loop <b>'for i in range(1, iterates):'</b> randomly selects one of the three vertices. Move halfway from the current point to the chosen vertex and store the new point. <br>

	<b>plt.figure(figsize=(8, 8)) <br>
	plt.scatter(x, y, color = 'r', s=0.1) <br>
	plt.title('Sierpinski Triangle Generated Using the Chaos Game')<br>
	plt.axis('equal')  # Ensure aspect ratio is equal for an equilateral triangle <br>
	plt.show()</b><br>
	
	This section of the code is responsible for visualizing the Sierpinski Triangle. 
	</p>
      </section>
     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

import matplotlib.pyplot as plt
from random import random, randint
import numpy as np

def midpoint(P, Q):
    return (0.5*(P[0] + Q[0]), 0.5*(P[1] + Q[1]))

vertices = [(0, 0), (2, 2*np.sqrt(3)), (4, 0)]
iterates = 50000
x, y = [0]*iterates, [0]*iterates
x[0], y[0] = random(), random()

for i in range(1, iterates):

    k = randint(0, 2)

    x[i], y[i] = midpoint( vertices[k], (x[i-1], y[i-1]) )

plt.figure(figsize=(8, 8))
plt.scatter(x, y, color = 'r', s=0.1)
plt.title('Sierpinski Triangle Generated Using the Chaos Game')
plt.axis('equal')  # Ensure aspect ratio is equal for an equilateral triangle
plt.show()

	</code></pre>


	 </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          The diagram below shows the Sierpinski Triangle generated using a Chaos Game
        </p>

        <figure>
          <img
            src="https://github.com/ayoung37/labreports/blob/main/Sierpinski%20Triangle%20(Chaos%20Game).PNG?raw=true"
            alt="Turtle Graphics Broad View"
            width="500"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong><br>Figure 1:</strong> Sierpinski Triangle generated using a Chaos Game.
          </figcaption>
        </figure>


      </section>


	<u><b>The Barnsley Fern </b></u><br>
	Barnsley's Fern is an example of a random point iteration that generates a fractal pattern. The transformation rules take any point (x, y) and return new values for x and y [3]. The transformation functions are defined as follows: <br>

def f1(x, y): <br>
    x = 0 <br>
    y = 0.16 * y <br>
    return x, y<br> 

def f2(x, y): <br>
    x_new = 0.85 * x + 0.04 * y <br>
    y_new = -0.04 * x + 0.85 * y + 1.6 <br>
    return x_new, y_new <br>

def f3(x, y): <br>
    x_new = 0.2 * x - 0.26 * y <br>
    y_new = 0.23 * x + 0.22 * y + 1.6 <br>
    return x_new, y_new <br>

def f4(x, y): <br>
    x_new = -0.15 * x + 0.28 * y <br>
    y_new = 0.26 * x + 0.24 * y + 0.44 <br>
    return x_new, y_new <br>
	    
These functions provide the necessary transformations to create the intricate fractal shape characteristic of Barnsley's Fern. <br> 

The first function, `f1`, represents the fern stem. The second function, `f2`, creates the largest portion of the Fern, which is the leafy part. The third function, `f3`, draws a smaller left leaflet, while the fourth function, `f4`, draws the smaller right leaflet.<br>

	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

import random
import matplotlib.pyplot as plt

# Define the transformation functions
def f1(x, y):
    x = 0
    y = 0.16 * y
    return x, y

def f2(x, y):
    x_new = 0.85 * x + 0.04 * y
    y_new = -0.04 * x + 0.85 * y + 1.6
    return x_new, y_new

def f3(x, y):
    x_new = 0.2 * x - 0.26 * y
    y_new = 0.23 * x + 0.22 * y + 1.6
    return x_new, y_new

def f4(x, y):
    x_new = -0.15 * x + 0.28 * y
    y_new = 0.26 * x + 0.24 * y + 0.44
    return x_new, y_new

# Probabilities for each function
probabilities = [0.01, 0.85, 0.07, 0.07]

# Barnsley Fern function
def barnsley_fern(iterations):
    x, y = 0, 0
    points = []

    for _ in range(iterations):
        rand = random.random()
        if rand   < sum(probabilities[:1]):
            x, y = f1(x, y)
        elif rand < sum(probabilities[:2]):
            x, y = f2(x, y)
        elif rand < sum(probabilities[:3]):
            x, y = f3(x, y)
        else:
            x, y = f4(x, y)

        points.append((x, y))

    return points

# Generate points for the Barnsley Fern
iterations = 100000
fern_points = barnsley_fern(iterations)

# Plot the Barnsley Fern
x_vals, y_vals = zip(*fern_points)
plt.figure(figsize=(6, 10))
plt.scatter(x_vals, y_vals, s=0.1, color='orange')
plt.title('Barnsley Fern')
plt.show()

	</code></pre>

 <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          The diagram below shows the Barnsley Fern generated using a Chaos Game
        </p>

        <figure>
          <img
            src="https://github.com/ayoung37/labreports/blob/main/Barnsley%20Fern.png?raw=true"
            alt="Turtle Graphics Broad View"
            width="500"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong><br>Figure 2:</strong> Barnsley Fern generated using a Chaos Game.
          </figcaption>
        </figure>


      </section>

<h2>Part 2: L - Systems </h2>
        <p>
  An L-system, or Lindenmayer system, is a parallel rewriting system and a type of formal grammar. It consists of an alphabet of symbols used to create strings, a collection of production rules that expand each symbol into a larger string, an initial "axiom" string from which construction begins, and a mechanism for translating the generated strings into geometric structures [4]. <br>
  <u><b>Fractal Trees</b></u><br>
The program begins by importing the turtle graphics library and displaying the turtle cursor. <br>
<b># Initialize the turtle<br>
initializeTurtle()<br>
showturtle()<br></b><br>

The function <b>def apply_rule(char, rules):</b> applies the L-system rule by replacing a character with its corresponding string defined in the rules. <br>

The function <b>def generate_lsystem(axiom, rules, iterations):</b> generates the L-System string. It starts with an initial string (the axiom) and then iteratively applies the production rules to create a complex string that represents the fractal structure. <br>

The function <b>def draw_lsystem(turtle_string, length, angle):</b> draws the L-System using turtle graphics. The commands include: <br>
- <b>'F'</b>: move forward by the specified length, drawing a line.<br>
- <b>'+'</b>: turn left by the given angle.<br>
- <b>'-'</b>: turn right by the specified angle.<br>
- <b>'['</b>: save the current position and heading, which is used for creating branches.<br>
- <b>']'</b>: restore the last saved position and heading.<br>

The three variables below defines the L-System rules.<br> 
<b># Define the L-system rules<br>
rules = {'F': 'FF-[-F+F+F]+[+F-F-F]'}<br>
axiom = 'F'<br>
iterations = 4<br></b>
The rules specify how each character is replaced during each iteration. The axiom serves as the starting point of the system, and the iterations represent the number of times the rules are applied.<br>


	</p>
      </section>
     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

# Initialize the turtle
initializeTurtle()
showturtle()

# Function to apply L-system rules
def apply_rule(char, rules):
    return rules.get(char, char)

# Function to generate L-system string
def generate_lsystem(axiom, rules, iterations):
    current_string = axiom
    for _ in range(iterations):
        current_string = ''.join([apply_rule(char, rules) for char in current_string])
    return current_string

# Function to draw the L-system with turtle
def draw_lsystem(turtle_string, length, angle):
    stack = []
    for command in turtle_string:
        if command == 'F':
            forward(length)
        elif command == '+':
            left(angle)
        elif command == '-':
            right(angle)
        elif command == '[':
            position = (getx(), gety())
            heading_angle = heading()
            stack.append((position, heading_angle))
        elif command == ']':
            position, heading_angle = stack.pop()
            jump(position[0], position[1])
            face(heading_angle)

# Define the L-system rules
rules = {'F':'FF-[-F+F+F]+[+F-F-F]'}

axiom = 'F'
iterations = 4

# Generate the L-system string
turtle_string = generate_lsystem(axiom, rules, iterations)

# Set up the turtle
jump(350, 500)
face(0)
color('green')

# Draw the L-system fractal tree
length = 8
angle = 25
draw_lsystem(turtle_string, length, angle)

# Display the drawing
show()



# Define the L-system rules
rules = {'F':'F[+F]F[-F]F'}

axiom = 'F'
iterations = 4

# Generate the L-system string
turtle_string = generate_lsystem(axiom, rules, iterations)

# Set up the turtle
jump(200, 500)
face(0)
color('purple')

# Draw the L-system fractal tree
length = 6
angle = 30
draw_lsystem(turtle_string, length, angle)

# Display the drawing
show()


# Define the L-system rules
rules = {'F':'F[+FF]F[-FF]F'}

axiom = 'F'
iterations = 5

# Generate the L-system string
turtle_string = generate_lsystem(axiom, rules, iterations)

# Set up the turtle
jump(700, 500)
face(0)
color('orange')

# Draw the L-system fractal tree
length = 6
angle = 30
draw_lsystem(turtle_string, length, angle)

# Display the drawing
show()

	</code></pre>


	 </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          The diagram below shows the L-System Fractal Tree. 
        </p>

        <figure>
          <img
            src="https://github.com/ayoung37/labreports/blob/main/L-System%20Fractal%20Trees.png?raw=true"
            alt="Turtle Graphics Broad View"
            width="500"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong><br>Figure 3:</strong> L-System Fractal Tree.
          </figcaption>
        </figure>


      </section>

<h2>Part 3: Hilbert Curves  </h2>
        <p>
  
	The fourth code focuses on Hilbert Curves. It is similar to the previous code in that it uses L-Systems and turtle graphics to create the Hilbert Curve. Below is a breakdown of the main components of the code.<br>

The function <b>draw_lsystem(turtle_string, length, angle)</b> is responsible for drawing the L-System using turtle graphics. The following commands are used: <br>  
- <b>'F'</b>: Move forward by the specified length, drawing a line. <br>    
- <b>'+'</b>: Turn left by the given angle. <br>  
- <b>`'-'</b>: Turn right by the specified angle. <br>  

The axiom serves as the starting point for the L-System, and the rules define how characters are replaced in each iteration to construct the fractal pattern. The axiom is defined as: <br>
<b>axiom = 'L'  <br>
rules = {  <br>
    'L': '-RF+LFL+FR-',  <br>
    'R': '+LF-RFR-FL+' <br> 
}  </b><br>

The formula <b>n = 2 ** iterations - 1</b> calculates the number of line segments, while <b>length = size / n</b> determines the length of each line segment to ensure the curve fits within the specified canvas size. 
	
	</p>
      </section>
     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">
# Initialize the turtle
initializeTurtle()
showturtle()

# Function to apply L-system rules
def apply_rules(char, rules):
    return rules.get(char, char)

# Function to generate L-system string
def generate_lsystem(axiom, rules, iterations):
    current_string = axiom
    for _ in range(iterations):
        next_string = ''.join([apply_rules(char, rules) for char in current_string])
        current_string = next_string
    return current_string

# Function to draw the L-system with turtle
def draw_lsystem(turtle_string, length, angle):
    for command in turtle_string:
        if command == 'F':
            forward(length)
        elif command == '+':
            left(angle)
        elif command == '-':
            right(angle)
        # 'L' and 'R' are placeholders; we ignore them in drawing
        else:
            pass  # Ignore other characters

# Set the parameters for the Hilbert Curve
axiom = 'L'
rules = {
    'L': '-RF+LFL+FR-',
    'R': '+LF-RFR-FL+'
}
iterations = 1  # Adjust the iterations to change the order (e.g., 1 to 5)
angle = 90

# Generate the L-system string for the Hilbert curve
hilbert_string = generate_lsystem(axiom, rules, iterations)

# Calculate the step size based on desired size and iterations
size = 200  # Total size of the Hilbert curve (adjust as needed)
n = 2 ** iterations - 1
length = size / n

# Move to starting position
jump(100, 300)  # Adjust the starting position to fit your canvas
face(0)
color('blue')

# Draw the Hilbert curve
draw_lsystem(hilbert_string, length, angle)

# Display the drawing
show()



iterations = 2  # Adjust the iterations to change the order (e.g., 1 to 5)
angle = 90

# Generate the L-system string for the Hilbert curve
hilbert_string = generate_lsystem(axiom, rules, iterations)

# Calculate the step size based on desired size and iterations
size = 200  # Total size of the Hilbert curve (adjust as needed)
n = 2 ** iterations - 1
length = size / n

# Move to starting position
jump(400, 300)  # Adjust the starting position to fit your canvas
face(0)
color('blue')

# Draw the Hilbert curve
draw_lsystem(hilbert_string, length, angle)

# Display the drawing
show()



iterations = 3  # Adjust the iterations to change the order (e.g., 1 to 5)
angle = 90

# Generate the L-system string for the Hilbert curve
hilbert_string = generate_lsystem(axiom, rules, iterations)

# Calculate the step size based on desired size and iterations
size = 200  # Total size of the Hilbert curve (adjust as needed)
n = 2 ** iterations - 1
length = size / n

# Move to starting position
jump(700, 300)  # Adjust the starting position to fit your canvas
face(0)
color('blue')

# Draw the Hilbert curve
draw_lsystem(hilbert_string, length, angle)

# Display the drawing
show()


iterations = 4  # Adjust the iterations to change the order (e.g., 1 to 5)
angle = 90

# Generate the L-system string for the Hilbert curve
hilbert_string = generate_lsystem(axiom, rules, iterations)

# Calculate the step size based on desired size and iterations
size = 200  # Total size of the Hilbert curve (adjust as needed)
n = 2 ** iterations - 1
length = size / n

# Move to starting position
jump(400, 550)  # Adjust the starting position to fit your canvas
face(0)
color('blue')

# Draw the Hilbert curve
draw_lsystem(hilbert_string, length, angle)

# Display the drawing
show()



		    
	</code></pre>


	 </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          The diagram below shows the Hilbert Curve. 
        </p>

	<figure>
          <img
            src="https://github.com/ayoung37/labreports/blob/main/Helbert%20Curve%20(Iterations%201-4).png?raw=true"
            alt="Turtle Graphics Broad View"
            width="500"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong><br>Figure 4:</strong> Illustration of the Hilbert Curve showing iterations 1 through 4.
          </figcaption>
        </figure> 
	      

        <figure>
          <img
            src="https://github.com/ayoung37/labreports/blob/main/Hilbert%20Curves.png?raw=true"
            alt="Turtle Graphics Broad View"
            width="500"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong><br>Figure 5:</strong> Illustration of the Hilbert Curve at iteration 5.
          </figcaption>
        </figure>
  


      </section>


      
	 <!-- REFERENCE SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------- ----------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
	    
	<section id="References">
        <h2>Reference</h2>
        <p> 
	[1] https://en.wikipedia.org/wiki/Chaos_game <br>
	[2] https://beltoforion.de/en/recreational_mathematics/chaos_game.php#:~:text=The%20number<br>
		%20of%20corner%20points,randomness%22%20of%20the%20corner%20selection<br>
	[3] https://thewessens.net/ClassroomApps/Main/chaosgame.html<br>
	[4] https://en.wikipedia.org/wiki/L-system<br>

	</p>
	
      </section>
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
